
The basic hook into porter will be in web.
saver will not be coupled to porter or storer.

web --> porter --> storer
               --> saver
    --> saver

This means that saver.group_exists?(id) could generate an ID-6
which is used in the 1st 6-chars of an existing 10-ID inside storer.
If this happens, then porter will need to map that 10-ID.

-------------------------------------------

Testing
-------
need collection of storer content (tgz files).
unzip this to a known dir on host.
volume mount this into storer (read-write)
volume mount this into porter too (read-only)
porter will access storer service and saver service.
Once it has successfully ported a kata from
storer, it will delete the kata from storer.
Would be best to do this as a shared data-container
as that is the way storer actually works.

Tool to pipe a storer's tgz file into storer's DC would
be nice. Can then do a manual test. Pipe kata with known
ID into DC. Access it from browser. See it work.
Then docker exec into the storer and see it has gone.
Then docker exec into the porter and see it's there.
Can do this for katas with duplicate 6-chars IDs too.
See their entries in porters map.

//-----------------------

Note that saver itself cannot create a group with an ID
unless that ID is unique in its first 6 chars (in its own VM).

However....
o) the IDs in the storer are 10 chars long and the IDs
   in URLs are 10 chars.
o) there are katas in the storer that are NOT unique
   in their first 6 chars.
So... create a persistent mapping for these.
This can be a simple id-map/ dir structure.

using-mapping
  save each kata in saver
  and record original 10-char-ID ==> new 6-char ID
  in a persistent map

//----------------------------------------------------------

 6-char ID: new saver ID
            no avatar-name --> individual session, id == kata-id
            has avatar-name --> group session, id==group-id. kata-id is hidden

10-char ID: old storer ID.
            always comes with an avatar-name too...
            eg this was created from [i'm on my own]
               http://www.cyber-dojo.org/kata/edit/e13AD0UkeY?avatar=eagle
            eg this was created from [we're in a group]
               http://www.cyber-dojo.org/kata/edit/9bkHemGPHR?avatar=dolphin

            id_6 = porter.port(id_10, avatar_name)

            and it will port that avatar
            will it also port all the other avatars (with that id_10) too?

//----------------------------------------------------------

porter.port(id-10)
  if there is a mapping match (for id-10)
     use that
  else if there is no kata-match (6-chars)
     then nothing to do, no match
  else if there is a single kata-match (6-chars)
     try and save it in grouper with this 6 char ID
     if it works use that
     if it fails use mapping (saver generates the ID)
  if there are 2+ kata-matches (6-chars)
     need to use mapping
     easiest is to use mapping for all duplicates
     feasible to try its own ID for one duplicate?

//----------------------------------------------------------

when porter is in place
new server's commander can still create empty Data-Container
it will simply never get filled!

//----------------------------------------------------------

The plan is for porter to be a service that
1) has a read-write volume-mount of storer's data-container
2) has a read-write volume-mount of singer's ids/ dir
3) has a read-write volume-mount of grouper's ids/ dir

It will then port katas from 1) into katas in 2/3)
It will have a single method in its API, port(id) which accepts
a kata-id in 1)

It does not access singler/grouper via their services for speed.
Hmmm. But maybe its better to use the grouper service?
Maybe it could have both!
You could do a grouper.create() and then have access to the
manifest/etc by knowing the ID and with the ID gain access
to the raw data in the dir. You could then rewrite the manifest
to the original ID and mv the dir to its new-ID dir.
This sounds quite fiddly.
Why not just allow grouper.create() to be passed a manifest
that already has an ID inside it.
If it can't honour the ID (eg taken or not uniquely completable)
then it raises.
If grouper.create() is passed a manifest without an ID in it
then it will generate a new ID as it currently does.

What if the kata on storer only has a single avatar?
Should porter then do a singler.create() directly?
No. That would complicate the ID mapping.
At the moment the only kata IDs are IDs in storer and these
always have avatars.

- newID?avatar=lion
  web will find saver.joined(newID) is not nil
  so porter will not be called
  (won't anyway since newID is 6-chars long)
  then web will get lion's kata-ID from saver.joined(newID) hash

- newID
  no avatar. new format. Must be a saver.kata_exists?(newID) is true

- oldID?avatar=lion
  web will find saver.group_exists?(oldID) is false
  porter wll do newID = port(oldID)
    then web will get lion's kata-ID from saver.joined(newID)

What to do when an individual tries to rejoin a kata is a different
question. If grouper.joined(ID) shows only a single avatar then
go straight to that.

I will also write a script which will call porter in a loop
and this port all of 1) to 2/3).

If port(id) matches the id against 1) then it will do what
saver.group_create() would do, but it will do it with the given
id, assuming that id is available and uniquely completeable.
It will then do what saver.join() would do for each avatar
in 1).
If port(id) succeeds it will delete the kata from 1).
I thought about doing a mv, but its simpler to delete
- it takes less disk space
- I can still record the IDs of successfully ported IDs
- I can rely on a whole disk backup.
- May need to revisit this
- What if several people are re-entering an old kata?
    what if several porter.port(kata_id) calls happen at the same time?

If port(id) fails, what should it do?
Move the kata to a special holding area?

How will I test this?
It needs to work for storer's katas many of which are very old.

//-----------------------

From web's app/model/Tag

  def colour
    # Very early dojos used outcome
    (@hash['colour'] || @hash['outcome'] || '').to_sym # CAN BE UPDATED
  end


Singler is now storing the stdout,stderr,status
in the tag file in a new format
{
  'files' => { filename=>content,... },
  'stdout' => 'dsfsdf',
  'stderr' => 'sdsdsd',
  'status' => 23
}

