
I have decided to switch to 6-char identifiers on grouper/singler.

I need to find out what is the fastest way to
arrange the dirs? 2/4 or 2/2/2 (or something else, eg 3/3)

There is a bash shortcut for creating a load of dirs using a range.
cd /tmp
mkdir -p /tmp/a/{0..9}/b
will create 10 nested dirs

Eg suppose I want to generate a dir "spread" to time 3/3

mkdir -p {000..999}
mkdir -p 435/{000..999}
mkdir -p 623/{000..999}
mkdir -p 119/{000..999}
mkdir -p 723/{000..999}
mkdir -p 183/{000..999}

this allws you to test 3/3
by generating 6,000 dirs instead of 1,000,000
To do the test use the known sample of 1st level 3's
  435,623,119,723,183
which can be picked at random.
Simplest to pick 10 and there will always be 10,
even for {0..9}
0..9 -> n=1, 00..99 -> n=2, 000.999 -> n=3 etc
(0..10**n).to_a.shuffle[0..9]

How many ways can you split 6?
1-5, 1-1-4 etc etc

  def partition(n, max = n)
    if n == 0
      [[]]
    else
      [max, n].min.downto(1).flat_map do |i|
        partition(n-i, i).map{ |rest| [i, *rest] }
      end
    end
  end
  # https://stackoverflow.com/questions/10889379/generating-unique-sorted-partitions-in-ruby

now need to create all permutations of each possibility

  [1,2,3].permutation.sort.uniq.entries
  [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]

giving...

    all = partition(6).inject([]) { |res,p| res += p.permutation.sort.uniq }
or
    all = partition(6).collect{ |p| p.permutation.sort.uniq }.flatten(1)

which is 32 different combinations
[[6], [1, 5], [5, 1], [2, 4], .... [2, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]

