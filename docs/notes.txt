
The basic hook into porter will be in web.
saver will not be coupled to porter or storer.

web --> porter --> storer
               --> saver --> storer

storer is coupled to saver.
This is because when saver generates an id
it must not clash with an existing, yet-to-be ported
id from storer. This is so that when a kata in
storer is ported it retains its id (1st 6 chars)
in saver unless that 6-char id is not unique.

-------------------------------------------

Testing
-------
need collection of storer content (tgz files).
Then tar-pipe these into the /usr/src/cyber-dojo/katas
dir inside storer.
Once porter has successfully ported a kata from
storer, it will delete the kata from storer.

Tool to pipe a storer's tgz file into storer's DC would
be nice. Can then do a manual test. Pipe kata with known
ID into DC. Access it from browser. See it work.
Then docker exec into the storer and see it has gone.
Then docker exec into the porter and see it's there.
Can do this for katas with duplicate 6-chars IDs too.
See their entries in porters id-map/.

//-----------------------

Note that saver itself cannot create a group with an ID
unless that ID is unique in its first 6 chars (in its own VM).

However....
o) the IDs in the storer are 10 chars long and the IDs
   in URLs are 10 chars.
o) there are katas in the storer that are NOT unique
   in their first 6 chars.
So... create a persistent mapping for these.
This can be a simple id-map/ dir structure.

using-mapping
  save each kata in saver
  and record original 10-char-ID ==> new 6-char ID
  in a persistent map

//----------------------------------------------------------

 6-char ID: new saver ID
            no avatar-name --> individual session, id == kata-id
            has avatar-name --> group session, id==group-id. kata-id is hidden

10-char ID: old storer ID.
            usually comes with an avatar-name too...
            eg this was created from [i'm on my own]
               http://www.cyber-dojo.org/kata/edit/e13AD0UkeY?avatar=eagle
            eg this was created from [we're in a group]
               http://www.cyber-dojo.org/kata/edit/9bkHemGPHR?avatar=dolphin

            id_6 = porter.port(partial_id)

//----------------------------------------------------------

when porter is in place
new server's commander can still create empty Data-Container
it will simply never get filled!

//----------------------------------------------------------

Why not just allow grouper.create() to be passed a manifest
that already has an ID inside it.
If it can't honour the ID (eg taken or not uniquely completable)
then it raises.
If grouper.create() is passed a manifest without an ID in it
then it will generate a new ID as it currently does.

What if the kata on storer only has a single avatar?
Should porter then do a singler.create() directly?
No. That would complicate the ID mapping.
At the moment the only kata IDs are IDs in storer and these
always have avatars.

- newID?avatar=lion
  web will find saver.joined(newID) is not nil
  so porter will not be called
  (won't anyway since newID is 6-chars long)
  then web will get lion's kata-ID from saver.joined(newID) hash

- newID
  no avatar. new format. Must be a saver.kata_exists?(newID) is true

- oldID?avatar=lion
  web will find saver.group_exists?(oldID) is false
  porter wll do newID = port(oldID)
    then web will get lion's kata-ID from saver.joined(newID)

What to do when an individual tries to rejoin a kata is a different
question. If grouper.joined(ID) shows only a single avatar then
go straight to that.

If port(id) matches the id in storer then it will do what
saver.group_create() would do, but it will do it with the given
id, assuming that id is available and uniquely completeable.
It will then do what saver.join() would do for each avatar
in storer.

If port(id) succeeds it will delete the kata from 1).
I thought about doing a mv, but its simpler to delete
- it takes less disk space
- I can still record the IDs of successfully ported IDs
- I can rely on a whole disk backup.
- May need to revisit this
- What if several people are re-entering an old kata?
    what if several porter.port(kata_id) calls happen at the same time?

If port(id) fails, what should it do?
Move the kata to a special holding area?

How will I test this?
It needs to work for storer's katas many of which are very old.

//-----------------------

From web's app/model/Tag

  def colour
    # Very early dojos used outcome
    (@hash['colour'] || @hash['outcome'] || '').to_sym # CAN BE UPDATED
  end


Singler is now storing the stdout,stderr,status
in the tag file in a new format
{
  'files' => { filename=>content,... },
  'stdout' => 'dsfsdf',
  'stderr' => 'sdsdsd',
  'status' => 23
}
